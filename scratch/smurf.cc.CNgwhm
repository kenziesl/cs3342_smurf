#include "cpp-peglib/peglib.h";
#include <fstream>
#include <iostream>
#include <sstream>

using namespace peg;
using namespace std;

auto grammar = R"(

               )";

string format_error_message(const string& path, size_t ln,
                            size_t col, const string& msg) {
    stringstream ss;
    ss << path << ":" << ln << ":" << col << ":" << msg << endl;
}

struct SymbolScope;

struct Annotation {
    shared_ptr<SymbolScope> scope;
};

typedef AstBase<Annotation> AstSmurf;
shared_ptr<SymbolScope> get_closest_scope(shared_ptr<astSmurf> ast) {
    ast = ast->parent;
    while(ast->tag != "code") {
        ast = ast->parent;
    }
    return ast->scope;
}

struct SymbolScope {
    SymbolScope(shared_ptr<SymbolScope> outer) : outer(outer) {}


    //These all may need to be redone
    bool has_symbol(const string& ident, bool extend=true) const {
        auto ret = constants.count(ident) || variables.count(ident);
        return ret ? true : (extend && outer
                             ? outer->has_symbol(ident)
                             : false);
    }

    bool has_constant(const string& ident, bool extend=true) {
        return constants.count(ident)
                ? true
                : (extend && outer ? outer->has_constant(ident) : false);
    }

    bool has_variable(const string& ident, bool extend=true) {
        return variables.count(ident)
                ? true
                : (extend && outer ? outer->has_variable(ident) : false);
    }

    bool has_procedure(const string& ident, bool extend=true) {
        return procedures.count(ident)
                ? true
                : (extend && outer ? outer->has_procedure(ident) : false);
    }

    shared_ptr<AstSmurf> get_procedure(const string& ident) const {
        auto it = procedures.find(ident);
        return it != procedures.end() ? it->second : outer->get_procedure(ident);
    }

    map<string, int> constants;
    set<string> variables;
    map<string, shared_ptr<AstSmurf>> procedures;
    set<string> free_variable;

private:
    shared_ptr<SymbolScope> outer;
};

void throw_runtime_error(vonst shared_ptr) {
    throw runtime_error(
                format_error_message(node->path, node->line, node->column, msg));
}

struct SymbolTable {
    static void build_on_ast(const shared_ptr<AstSmurf> ast,
                             shared_ptr<SymbolScope> scope = nullptr) {
        switch (ast->tag) {

        }
    }
};
